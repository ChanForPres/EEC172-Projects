//*****************************************************************************
//
// spi_master.c - Example demonstrating how to configure SSI0 in SPI master
//                mode.
//
// Copyright (c) 2010-2014 Texas Instruments Incorporated.  All rights reserved.
// Software License Agreement
// 
//   Redistribution and use in source and binary forms, with or without
//   modification, are permitted provided that the following conditions
//   are met:
// 
//   Redistributions of source code must retain the above copyright
//   notice, this list of conditions and the following disclaimer.
// 
//   Redistributions in binary form must reproduce the above copyright
//   notice, this list of conditions and the following disclaimer in the
//   documentation and/or other materials provided with the  
//   distribution.
// 
//   Neither the name of Texas Instruments Incorporated nor the names of
//   its contributors may be used to endorse or promote products derived
//   from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 
// This is part of revision 2.1.0.12573 of the Tiva Firmware Development Package.
//
//*****************************************************************************

#include <stdbool.h>
#include <stdint.h>
#include "inc/tm4c123gh6pm.h"
#include "inc/hw_memmap.h"
#include "inc/hw_types.h"
#include "inc/hw_nvic.h"
#include "driverlib/debug.h"
#include "driverlib/fpu.h"
#include "driverlib/gpio.h"
#include "driverlib/interrupt.h"
#include "driverlib/pin_map.h"
#include "driverlib/ssi.h"
#include "driverlib/sysctl.h"
#include "driverlib/uart.h"
#include "utils/uartstdio.h"
#include "driverlib/rom.h"

#include "driverlib/Adafruit_SSD1351.h"
#include "glcdfont.h"

//**********************************************
int WIDTH,HEIGHT;
int _width  , _height  ;
int rotation;
int cursor_y ,cursor_x ; 
int textsize ;
int textcolor ,textbgcolor;
int wrap   ;
const int INT_BIT0_MIN = 50000;
const int INT_BIT0_MAX = 60000;
const int INT_BIT1_MIN = 100000;
const int INT_BIT1_MAX = 120000;
const int PERIOD =16000000;

volatile int repeat = 0;
volatile int iTick = 0;
volatile int TIME = 0;
volatile int signal1 = 0;
volatile int signal2 = 0;
volatile int COUNT = 0;

//********************************************
//*****************************************************************************
//
//! \addtogroup ssi_examples_list
//! <h1>SPI Master (spi_master)</h1>
//!
//! This example shows how to configure the SSI0 as SPI Master.  The code will
//! send three characters on the master Tx then polls the receive FIFO until
//! 3 characters are received on the master Rx.
//!
//! This example uses the following peripherals and I/O signals.  You must
//! review these and change as needed for your own board:
//! - SSI0 peripheral
//! - GPIO Port A peripheral (for SSI0 pins)
//! - SSI0Clk - PA2
//! - SSI0Fss - PA3
//! - SSI0Rx  - PA4
//! - SSI0Tx  - PA5
//!
//! The following UART signals are configured only for displaying console
//! messages for this example.  These are not required for operation of SSI0.
//! - UART0 peripheral
//! - GPIO Port A peripheral (for UART0 pins)
//! - UART0RX - PA0
//! - UART0TX - PA1
//!
//! This example uses the following interrupt handlers.  To use this example
//! in your own application you must add these interrupt handlers to your
//! vector table.
//! - None.
//
//*****************************************************************************

//*****************************************************************************
//
// Number of bytes to send and receive.
//
//*****************************************************************************
#define NUM_SSI_DATA            3

//*****************************************************************************
//
// This function sets up UART0 to be used for a console to display information
// as the example is running.
//
//*****************************************************************************


void
InitConsole(void)
{
    // Enable GPIO port A which is used for UART0 pins.
    // Enable UART0.
    //
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);
	//  ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);

	
    // Configure the pin muxing for UART0 functions on port A0 and A1.
    // Select the alternate (UART) function for these pins.
    //
    ROM_GPIOPinConfigure(GPIO_PA0_U0RX);
    ROM_GPIOPinConfigure(GPIO_PA1_U0TX);
    GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);

    // Use the internal 16MHz oscillator as the UART clock source.
    //
    UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC);
    // Initialize UART0 for console I/O. (See uartstdio.c)
    //
		UARTStdioConfig(0, 115200, 16000000);

		// configure SSI 
}
		/*
			Signal is comprised of 32 bits. The first 16 bits are the address which is the same
			due to the address corresponding to a certain brand/machine. Hence, this isn't important because
			we are assuming that the receiver is compatible with the transmission type. The last 16 bits will always
			differ due it corresponding to the button that is being pressed. The 32 bits are then ANDED with 0x0000FFFFF
			which will leave us with the last 16 bits. Then, those 16 bits are compared to 
			the hexadecimal values of the button. I chose to use if statements (could use switches too).
		*/

void translate(void)
{
			int value = 0;
			signal1 = signal1 & 0xFFFF;
			if(signal1 == 0x807F)
			/*
				if (repeat != 0)
					value = repeat % 3;
					if (value == 1)
						drawChar
				else
					draw
			*/
				UARTprintf("1\n");
			else if(signal1 == 0x40BF)
				UARTprintf("2\n");
			else if(signal1 == 0xC03F)
				UARTprintf("3\n");
			else if(signal1 == 0x20DF)
				UARTprintf("4\n");
			else if(signal1 == 0xA05F)
				UARTprintf("5\n");
			else if(signal1 == 0x609F)
				UARTprintf("6\n");
			else if(signal1 == 0xE01F)
				UARTprintf("7\n");
			else if(signal1 == 0x10EF)
				UARTprintf("8\n");
			else if(signal1 == 0x906F)
				UARTprintf("9\n");
			else if(signal1 == 0x00FF)
				UARTprintf("0\n");
}

void SIGNAL(void)
{
	/*
		Make sure that the Time difference isn't too long; otherwise it is the beginning
		If it isn't too long, then we can start taking down the first 32 time measurements
		the signal's time is checked between the ranges and determined to be a 0 or 1
		Two possible ways of storing: array or int. I chose int because this means I wouldn't
		have to deal with locations. In the int, all I have to do is shift it left once and then
		add the new bit digit.
	*/
	if(TIME > 500000)
	{
		COUNT = COUNT;
	}
	else
	{
		if(COUNT <= 32)
		{
			UARTprintf("I work. 2\n");
			if((TIME > INT_BIT0_MIN) && (TIME < INT_BIT0_MAX))
			{
				signal1 = (signal1 << 1) + 0;
			}
			else if(TIME > INT_BIT1_MIN && TIME < INT_BIT1_MAX)
			{
				signal1 = (signal1 << 1) + 1;
			}
		}
		else
		{
			if(COUNT % 32 == 0 && COUNT != 32)
			{
				if( signal1 == signal2 )
				{
					repeat++;
					signal2 = 0;
				}
				else
				{
					translate();
					repeat = 0;
					signal1 = signal2;
					signal2 = 0;
					
				}
			}
			if((TIME > INT_BIT0_MIN) && (TIME < INT_BIT0_MAX))
			{
				signal2 = (signal2 << 1) + 0;
			}
			else if(TIME > INT_BIT1_MIN && TIME < INT_BIT1_MAX)
			{
				signal2 = (signal2 << 1) + 1;
			}
		}
		COUNT++;
	}
}
//*****************************************************************************
//
// Configure SSI0 in master Freescale (SPI) mode.  This example will send out
// 3 bytes of data, then wait for 3 bytes of data to come in.  This will all be
// done using the polling method.
//

void initialize(void)
{

    // Enable the GPIO port that is used for the on-board LED.
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);
	
	//Enable Pin 3 for input
	ROM_GPIOPinTypeGPIOInput(GPIO_PORTD_BASE, GPIO_PIN_3);
	
	/*
		Configuring the Interrupt Parameters to use
	*/
	ROM_SysTickPeriodSet(16000000);
	ROM_SysTickEnable();
	ROM_SysTickIntEnable();
	
	/*
		Interrupt is caused on the falling edges and read in from PD3
	*/
	ROM_GPIOIntTypeSet(GPIO_PORTD_BASE, GPIO_PIN_3, GPIO_FALLING_EDGE);
    GPIOIntEnable(GPIO_PORTD_BASE, GPIO_INT_PIN_3);
    ROM_IntEnable(INT_GPIOD);
    ROM_IntMasterEnable();
	UARTprintf("DONE INITIALIZING");
}


void SYS_TICK_IR_HANDLER(void)
{
	iTick++;
}

/*
	This is my interrupt handler. Whenever an interrupt is detected on the falling edge,
	it will call this function. I use PD3 to detect the time difference. The time difference
	between falling edges determines what value was sent. 
*/
void IR_HANDLER(void)
{
	GPIOIntClear(GPIO_PORTD_BASE, GPIO_INT_PIN_3);
	TIME = PERIOD - ROM_SysTickValueGet();
	UARTprintf("%d\n",TIME);
	NVIC_ST_CURRENT_R = 0x00; 
	/*
	if(TIME > 500000)
	{
		COUNT = COUNT;
	}
	else
	{
		if(COUNT <= 32)
		{
			UARTprintf("I work. 2\n");
			if((TIME > INT_BIT0_MIN) && (TIME < INT_BIT0_MAX))
			{
				signal1 = (signal1 << 1) + 0;
			}
			else if(TIME > INT_BIT1_MIN && TIME < INT_BIT1_MAX)
			{
				signal1 = (signal1 << 1) + 1;
			}
		}
		else
		{
			if(COUNT % 32 == 0 && COUNT != 32)
			{
				if( signal1 == signal2 )
				{
					repeat++;
					signal2 = 0;
				}
				else
				{
					translate();
					repeat = 0;
					signal1 = signal2;
					signal2 = 0;
					
				}
			}
			if((TIME > INT_BIT0_MIN) && (TIME < INT_BIT0_MAX))
			{
				signal2 = (signal2 << 1) + 0;
			}
			else if(TIME > INT_BIT1_MIN && TIME < INT_BIT1_MAX)
			{
				signal2 = (signal2 << 1) + 1;
			}
		}
		COUNT++;
	}
	*/
}

int main(void){
	/*
    uint32_t pui32DataTx[NUM_SSI_DATA];
    uint32_t pui32DataRx[NUM_SSI_DATA];
    uint32_t ui32Index;
	*/

    //
    // Set the clocking to run directly from the external crystal/oscillator.
    //
    ROM_SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_OSC_MAIN | 
							SYSCTL_XTAL_16MHZ);

    // The SSI0 peripheral must be enabled for use.
    //
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_SSI0);

    // For this example SSI0 is used with PortA[5:2].
		// GPIO port A needs to be enabled so these pins can be used.
    //
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
		ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);

    // Configure the pin muxing for SSI0 functions on port A2, A3, A4, and A5.
    //
    GPIOPinConfigure(GPIO_PA2_SSI0CLK);
    GPIOPinConfigure(GPIO_PA3_SSI0FSS);
    //GPIOPinConfigure(GPIO_PA4_SSI0RX);
    GPIOPinConfigure(GPIO_PA5_SSI0TX);

    // Configure the GPIO settings for the SSI pins.  This function also gives
    // control of these pins to the SSI hardware.  Consult the data sheet to
    // see which functions are allocated per pin.
    // The pins are assigned as follows:
    //      PA5 - SSI0Tx
    //      PA4 - SSI0Rx
    //      PA3 - SSI0Fss
    //      PA2 - SSI0CLK
    //
    ROM_GPIOPinTypeSSI(GPIO_PORTA_BASE, GPIO_PIN_5 | GPIO_PIN_3 |
                   GPIO_PIN_2);
		ROM_GPIOPinTypeGPIOOutput(GPIO_PORTB_BASE, GPIO_PIN_4 | GPIO_PIN_5);
    //
    // Configure and enable the SSI port for SPI master mode.  Use SSI0,
    // system clock supply, idle clock level low and active low clock in
    // freescale SPI mode, master mode, 1MHz SSI frequency, and 8-bit data.
    // For SPI mode, you can set the polarity of the SSI clock when the SSI
    // unit is idle.  You can also configure what clock edge you want to
    // capture data on.  Please reference the datasheet for more information on
    // the different SPI modes.

    ROM_SSIConfigSetExpClk(SSI0_BASE, SysCtlClockGet(), SSI_FRF_MOTO_MODE_0,
                       SSI_MODE_MASTER, 1000000, 8);

    // Enable the SSI0 module.
    //
		ROM_SSIEnable(SSI0_BASE);

		InitConsole();
		initialize();
		//fillScreen(0x00);
		UARTprintf("I work. 2");
		while(1){
		}
		
		
		
    return(0);
}
